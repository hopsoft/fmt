# Generated from lib/fmt/parsers/argument_parser.rb with RBS::Inline

module Fmt
  class ArgumentParser < Parser
    # Tokenizer for argument strings
    # Extracts args and kwargs from the source string
    #
    # Ripper.lex cheatsheet: @see doc/lexer.md
    #
    # @example Ripper Tokens
    #   [[lineno, column], type, token, state]
    class Tokenizer
      # Initializes a ArgumentTokenizer instance
      # @rbs source: String -- source string to tokenize
      # @rbs return: Fmt::ArgumentTokenizer
      def initialize: (String source) -> Fmt::ArgumentTokenizer

      attr_reader source: untyped

      attr_reader args: untyped

      attr_reader kwargs: untyped

      # Returns a hash of the tokenized arguments
      # @rbs return: Hash[Symbol, Object]
      def to_h: () -> Hash[Symbol, Object]

      private

      attr_reader key: untyped

      attr_reader composite: untyped

      # Tokenizes the source string (extracts args and kwargs)
      def tokenize: () -> untyped

      # Indicates if the lexeme should be skipped
      # @rbs lexeme: [[Integer, Integer], Symbol, String, Object] -- lexeme to check
      # @rbs return: bool
      def skip?: ([ [ Integer, Integer ], Symbol, String, Object ] lexeme) -> bool

      # Indicates if the tokenizer is currently working with an ordinal argument
      # @rbs return: bool
      def arg?: () -> bool

      # Indicates if the tokenizer is currently working with a keyword argument
      # @rbs return: bool
      def kwarg?: () -> bool

      # Indicates if the tokenizer is currently working with a composite argument
      # @rbs return: bool
      def composite?: () -> bool

      # Indicates if the lexeme is a supported primitive argument
      # @rbs lexeme: [[Integer, Integer], Symbol, String, Object] -- lexeme to check
      # @rbs return: bool
      def primitive?: ([ [ Integer, Integer ], Symbol, String, Object ] lexeme) -> bool

      # Type casts the lexeme to a supported primitive
      # @rbs lexeme: [[Integer, Integer], Symbol, String, Object] -- lexeme to check
      # @rbs return: String | Symbol | Integer | Float | Rational | Complex | bool | nil
      def cast_primitive: ([ [ Integer, Integer ], Symbol, String, Object ] lexeme) -> (String | Symbol | Integer | Float | Rational | Complex | bool | nil)

      # Assigns the lexeme to the appropriate location (i.e. args, composite, or kwargs)
      # @rbs lexeme: [[Integer, Integer], Symbol, String, Object] -- lexeme to check
      # @rbs return: void
      def assign_primitive: ([ [ Integer, Integer ], Symbol, String, Object ] lexeme) -> void

      # Indicates if the lexeme is the start of a composite argument (i.e. Array or Hash)
      # @rbs lexeme: [[Integer, Integer], Symbol, String, Object] -- lexeme to check
      # @rbs return: bool
      def composite_start?: ([ [ Integer, Integer ], Symbol, String, Object ] lexeme) -> bool

      # Indicates if the lexeme is the end of a composite argument (i.e. Array or Hash)
      # @rbs lexeme: [[Integer, Integer], Symbol, String, Object] -- lexeme to check
      # @rbs return: bool
      def composite_end?: ([ [ Integer, Integer ], Symbol, String, Object ] lexeme) -> bool

      # Creates a new composite argument based on the lexeme (i.e. Array or Hash)
      # @rbs lexeme: [[Integer, Integer], Symbol, String, Object] -- lexeme to check
      # @rbs return: Array | Hash | nil
      def new_composite: ([ [ Integer, Integer ], Symbol, String, Object ] lexeme) -> (Array | Hash | nil)

      # Assigns the composite argument to the appropriate location (i.e. args or kwargs)
      # @rbs return: void
      def assign_composite: () -> void

      # Indicates if the lexeme is Hash key
      # @rbs lexeme: [[Integer, Integer], Symbol, String, Object] -- lexeme to check
      # @rbs return: bool
      def key?: ([ [ Integer, Integer ], Symbol, String, Object ] lexeme) -> bool

      # Creates a new Hash key based on the lexeme
      # @rbs lexeme: [[Integer, Integer], Symbol, String, Object] -- lexeme to check
      # @rbs return: Symbol
      def new_key: ([ [ Integer, Integer ], Symbol, String, Object ] lexeme) -> Symbol
    end

    # Tokenizes the source string and returns a hash of the tokenized arguments
    # @rbs return: Hash[Symbol, Object]
    def perform: () -> Hash[Symbol, Object]
  end
end
